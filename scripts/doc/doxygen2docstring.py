# -*- coding: utf-8 -*-
""" doxygen2docstring.py

  This script converts XML file generated by Doxygen (C++)
  into docstring format (Python). The output is a C++ file
  containing char* strings of docstring values, available as
  constants. They can be used with pybind11 for sharing C++
  documentation to Python binding.
  
  Project: tubex-lib
  Author: Simon Rohou
  Date: 2020
"""

import xml.etree.ElementTree as ET

namespace = "tubex"
xml_doc = "classtubex_1_1_tube"
indent = "  "


def anchor_id(full_anchor_name, xml_name):
  '''
  Extract the anchor id from full string name obtained from Doxygen  <anchor> tag
  '''
  return full_anchor_name.replace(xml_name + "_1", "")

def normalize(str):
  '''
  Performs normalization on str: removes C++ conventions, converts
  some math symbols, trim the string, etc.
  '''
  return str.replace("const", "") \
            .replace("std::", "") \
            .replace("ibex::", "") \
            .replace("tubex::", "") \
            .replace("< ", "<") \
            .replace(" >", ">") \
            .replace("*", "") \
            .replace("\\cdot", "·") \
            .replace("\\infty", "∞") \
            .replace("\\forall", "∀") \
            .replace("\\in[", "ϵ[") \
            .replace("\\in ", "ϵ ") \
            .replace("\\int", "∫") \
            .replace("\\tau", "τ") \
            .replace("\\exists ", "∃ ") \
            .replace("\\mid ", " | ") \
            .replace("::", ".") \
            .replace("  ", " ") \
            .replace("$", "") \
            .replace("\n", "") \
            .replace("&", "").strip()

def get_tags_text(tag):
  '''
  Return the content of a tag, including the content of its sub-items.
  '''
  return normalize("".join(tag.itertext()))

def sentence(str):
  '''
  Adds a point at the end of str, if not already present.
  '''
  return (str + ".").replace("..",".")



# Parsing XML file from Doxygen output (XML mode enabled)

tree = ET.parse(xml_doc + ".xml")
root = tree.getroot()

# Refers to all memberdef containing an <anchor> tag
for memberdef in root.findall(".//anchor/../../.."):

  # Parsing anchor id (the one from XML is too long)
  # We obtain the anchor set in the C++ doc
  for anchor in memberdef.iter("anchor"):
    doc_id = anchor_id(anchor.get("id"), xml_doc)

  # Could be classes, etc.
  if memberdef.get("kind") == "function":

    # Doc string
    print("const char* " +  doc_id +  " = R\"_docs(", end="")

    # Brief description
    briefdescription = sentence(get_tags_text(memberdef.find("briefdescription")))
    print(briefdescription)

    # Optional notes
    list_notes = memberdef.findall(".//simplesect[@kind='note']")
    if len(list_notes):
      print("")
    for note in list_notes:
      print(sentence(get_tags_text(note)))

    # List of arguments (if any)
    params = memberdef.findall("./param")
    parameterlist = memberdef.find("detaileddescription/para/parameterlist")

    if len(params):
      print("\nArgs:")

      for param in params:
        param_name = param.find("declname").text
        print(indent + param_name, "(" + get_tags_text(param.find("type")) + "): ", end='')

        for parameteritem in parameterlist.iter("parameteritem"):
          if parameteritem.find("parameternamelist").find("parametername").text == param_name:
            param_description = sentence(get_tags_text(parameteritem.find("parameterdescription")))
            print(param_description)

    # Return value (if any)
    return_val = memberdef.find(".//simplesect[@kind='return']")
    if return_val:
      print("\nReturns:")
      print(indent + sentence(get_tags_text(return_val.find("para"))))

    # Ending
    print(")_docs\";\n")
    print("// ---------------------------------------------")